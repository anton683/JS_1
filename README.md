# JS_1
## Основы программирования на JavaScript 1

JavaScript — интерпретируемый, объектно-ориентированный язык программирования.
Функция — это мини-программа, с помощью которой можно что-то сделать. 
Например, мы хотим вывести сообщение, для этого есть функция alert. 
```js 
alert('Hello, world!')
```

Команда console.log очень часто используется для вывода отладочной информgit ации. 
```js 
console.log(123);
```

Тег script позволяет вставить JavaScript-код на сайт. 
```js 
<script></script> 
```

Чтобы подключить внешний файл JavaScript-кода, надо использовать атрибут src: 
```js 
<script src="js/script.js"></script>
```

Можно указать ссылку на файл (URL-адрес), например: 
```js 
<script src="https://example.com/somescripts/script.js"></script>
```

Переменная — это область памяти, где можно хранить и изменять данные. 
У переменной всегда есть имя, по нему мы можем обращаться к данным.  
```js 
let address = "Санкт-Петербург";
```

Также можно объявлять и инициализировать сразу несколько переменных: 
```js 
let name = "Вася", address = "Санкт-Петербург";
```

Названия переменных могут состоять из букв, цифр и знаков _ или $. При этом имя переменной не может начинаться с цифры: 
```js 
let 123; // Ошибка!
```

В JavaScript есть два самых популярных стиля написания составных слов: camelCase и snake_case. 
```js 
let firstName; let first_name;
```

Неизменяемые значения лучше всего называть словами в верхнем регистре. 
```js 
const PASSWORD_MIN_LENGTH = 8;
```

С помощью оператора let можно создать переменную, значение которой можно перезаписать: 
```js 
let myFavouriteColor = "blue"; 
myFavouriteColor = "orange";
```

Оператор var — устаревший аналог оператора let. В современных программах его уже не используют.
```js 
let year_of_foundation=1841; // цифры без ковычек 
```

Есть однострочные и многострочные комментарии. Такие комментарии начинаются со специальных символов //
Любой текст между // и концом строки будет игнорироваться JavaScript, то есть не будет выполняться. 
Многострочные комментарии начинаются символами /* и заканчиваются */.

Всего на данный момент есть восемь типов данных: string,
number,
boolean,
null,
undefined,
object,
Symbol,
BigInt.

Существует три вида кавычек: Объявление через одинарные и двойные кавычки ничем не отличается.
Одинарные — 'Hello, world!',
Двойные — "Hello, world!",
Обратные — `Hello, world!`.

таблица со всеми последовательностями в JavaScript:
Код	Значение
\0	нулевой символ (символ NUL)
\'	одинарная кавычка
\"	двойная кавычка
\\	обратный слеш
\n	новая строка
\r	возврат каретки
\v	вертикальная табуляция
\t	табуляция
\b	забой
\f	подача страницы
\uXXXX	кодовая точка Unicode
\xXX	символ из кодировки Latin-1
на практике чаще всего используются символы кавычек (\" и \') и новой строки (\n).

Если нужен текст с переносами, можно использовать символ \n: 
```js 
console.log("Первая строка\nВторая строка");
```

С помощью обратных кавычек мы можем вставлять в текст различные выражения. 
вместо 

```js 
const name = "Петр";
const greeting = "Привет " + name + "!"; // Привет Петр!
```
ставим
```js 
const greeting = `Привет ${name}!`;
```

В шаблонных строках можно и так:
```js 
console.log(`Первая строка
Вторая строка`); 
```

У строк есть лишь одно свойство — str.length, которое показывает длину строки str:
```js 
console.log("ООО \"ГринКорп\"".length); // 14
console.log("".length); // 0
```

Каждый символ в строке имеет свой индекс (позицию). Индексация начинается с 0
Есть несколько способов получить символ по позиции:
1. Используя метод str.charAt(index), где index — значение от 0 до длины строки минус 1. Если index выходит за пределы длины, метод вернет пустую строку
```js 
console.log("Привет".charAt(1)); // р
console.log("Привет".charAt(100)); // пустая строка
```
1. Используя квадратные скобки [index]: 
```js
console.log("Привет"[1]); // р
```
На практике чаще используется метод с квадратными скобками

Метод str.toLowerCase приводит все символы к нижнему регистру: 
```js
console.log("Привет, Петр".toLowerCase()); // привет, петр
```
Метод str.toUpperCase приводит все символы к верхнему регистру:
```js
console.log("Привет, Петр".toUpperCase()); // ПРИВЕТ, ПЕТР
```

Иногда мы на вход получаем строку, у которой в начале и конце есть ненужные нам пробельные символы (пробел, табуляцию, перенос строки и пр.). Чтобы избавиться от них, есть метод str.trim().
```js 
console.log("   Привет, Петр   ".trim()) // "Привет, Петр"
```

Среди чисел существует еще несколько специальных значений — Infinity и NaN.
Работает Infinity, как и бесконечность в математике: любое число + бесконечность = бесконечность.
Число, деленное на бесконечность, дает 0. Ну а число, деленное на 0, дает бесконечность:
```js
console.log(10 / 0); // Infinity
console.log(1 + Infinity); // Infinity
console.log(10000 / Infinity); // 0
```

NaN — сокращение от Not A Number, т. е. это не число. NaN появляется при ошибках в вычислении.
Например, если попытаться слово поделить на число, в результате получится NaN:
```js
console.log("Hello" / 2); // NaN
```
При этом у значения NaN есть несколько особенностей:
Оно ничему не равно, даже другому NaN. 
Какие бы математические операции мы ни проводили с ним, всегда будет получаться NaN.

Операторы делятся на несколько категорий:
1. Бинарные — работают сразу с двумя операндами (слева и справа). Например, оператор плюс (+) в выражении 1 + 2 работает с левым операндом 1 и правым 2.
2. Унарные — работают с 1 операндом. Например, оператор минус (-), который меняет знак:
```js
let a = 1;
let b = -a;
```
1. Тернарные — работают сразу с тремя операндами. 

Глобальный объект Math:
Math.ceil(x) — округление вверх. Вернет ближайшее большее целое число: 
```js
console.log(Math.ceil(1.01)); // 2
```
Math.floor(x) — округление вниз. Вернет ближайшее меньшее целое число: 
```js
console.log(Math.floor(1.01)); // 1
```
Math.round(x) — округление до ближайшего целого числа:  
```js
console.log(Math.round(1.01)); // 1
```
Math.trunc(x) — вернет целую часть числа (не поддерживается в браузере Internet Explorer)  
Поиск максимального и минимального значения: 
```js
Math.max(x1 …[, xN]) / Math.min(x1, …[, xN])
```

Работа со степенями:
Math.pow(x, exponent) — возведение x в степень exponent.
Math.sqrt(x) — возвращение квадратного корня x.
Math.cbrt(x) — возвращение кубического корня x.
Math.exp(x) — возвращение e в степени x.

Работа со знаками:
Math.abs(x) — возвращение абсолютного значения x (отбрасывает знак).
Math.sign(x) — возвращение знака числа x.

Получение случайного числа: Math.random()
К примеру, можем написать функцию, которая выдает случайное целое число меньше max:
```js
function getRandomInt(max) {
  return Math.floor(Math.random() * max);
  }
```
Константы:
Math.E — основание натурального логарифма.
Math.LN10 — натуральный логарифм из 10.
Math.LN2 — натуральный логарифм из 2.
Math.PI — число Пи.

Потеря точности:
```js
console.log(0.1 + 0.2 === 0.3); // false
console.log(0.1 + 0.2); // 0.30000000000000004
Чтобы проверить, есть ли ошибки, используйте toFixed.  console.log((0.1 + 0.2).toFixed(1) === "0.3") // true
```
Типы Boolean, null, undefined
Тип Boolean также называют булевым, или логическим, типом. У него всего два значения: true и false
Объявить булевую переменную можно напрямую, указав true или false: let a = true; let b = false;
Также булевый тип получается в результате вычисления выражений с операторами сравнения:
1. Меньше (<):
```js 
console.log(1 < 5); // true
```
2. Меньше или равно (<=): 
```js
console.log(5 <= 5); // true
```
3. Больше (>): 
```js
console.log(5 > 5); // false
```
4. Больше или равно (>=): 
```js
console.log(5 >= 5); // true
```
6. Равенство (==). Этот оператор сравнивает два операнда и, если они равны, возвращает true, иначе — false: 
```js
console.log(10 == 10); // true  console.log(10 == 9); // false
```
7. Строгое равенство (===). Этот оператор также сравнивает два операнда и возвращает true (если они равны), и false (если нет). Однако если прошлый оператор при сравнении числа 5 и строки '5' давал true, в случае строгого равенства результат будет false т.к. у них разный тип:  
```js
console.log(5 === '5'); // false
```
8. Отрицание (!). Оператор отрицания еще называют НЕ. Он возвращает обратное булевое значение: 
```js
console.log(!true); // false
```
9.  Не равно (!=) — комбинация оператора равенства и отрицания. Он проверяет, что два значения не равны друг другу, и возвращает true, если не равны, а иначе — false:
```js
console.log('A' != 'B'); // true  
console.log(5 != '5'); // false
```
1. Строгое неравенство (!==) — комбинация строгого неравенства и отрицания:
```js
console.log('A' !== 'B'); // true
console.log(5 !== '5'); // true
```

Тип null
означает что в переменной «ничего нет» — например, пустую корзину покупок можно обозначить null.   
```js
const value = null;
```
Тип undefined
Когда значение не было задано, мы имеем дело с типом undefined:
```js 
let x;
console.log(x); // undefined
```

Некоторые путают null и undefined, но надо научиться их различать:
undefined — значение не задано;
null — значение задано, но оно пустое либо неизвестно.
let login;
```js
console.log(login); // undefined, логин ещё не задали
login = null; // null, значение задали и оно пустое, значит логина нет
```
Объекты 
являются главным и самым сложным типом в JavaScript, внутри которой может находиться множество свойств. Свойством является пара ключ: значение
Остальные типы составляют отдельную категорию — примитивы.
Есть несколько способов создать объект:
```js
let myObj = new Object();  
```
и
```js
let myObj = {};
```
```js
let myObj = {
  key1: 'first key',
  key2: 222,
  myThirdKey: true,
  "key with spaces": {},
  12: null
};
```
Доступ к значениям свойств осуществляется двумя способами:
1. Через точку:
```js
console.log(myObj.key1); // 'first key'
```
1. Через квадратные скобки.
```js
console.log(myObj["key with spaces"]); // {}
```

Чтобы добавить или изменить свойство, достаточно обратиться к объекту по ключу и записать в него значение:
```js
myObj.test = 0;
console.log(myObj.test); // 0
```

Удаление свойств
Для удаления свойства существует оператор delete:
```js
delete myObj.test;
console.log(myObj.test); // undefined
```

Оператор typeof
Иногда непонятно, с каким типом мы сейчас работаем: Тип переменной распознает typeof.
Его можно использовать двумя способами: как унарный оператор typeof x и как функцию typeof(x). Результатом будет строка, в которой будет указан тип:
```js script
console.log(typeof 12); // number
console.log(typeof 1n) // bigint
console.log(typeof "12"); // string
console.log(typeof true); // boolean
console.log(typeof Symbol()); // symbol
console.log(typeof undefined); // undefined
console.log(typeof {a: 1}); // object
console.log(typeof alert);// function
console.log(typeof null); // object
```
typeof null выводит object. Это официально признанная ошибка, допущенная при создании JavaScript.

Преобразования типов
Есть несколько способов создать строку из переменной другого типа:
1. Использовать конструкцию String(variable):
```js script
let str = String(null); // "null"
str = String(12); // "12"
```
1. Вызвать метод toString(). Практически у каждого типа есть метод toString, который приведет значение к строке. Исключениями являются null и undefined:
```js script
let num = 100;
str = num.toString(); // "100"
null.toString() // Ошибка!
```
Правила преобразования
Практически из всех типов преобразования происходят очевидным образом: 100 будет преобразовано в "100", 100n в "100", false в "false", undefined в "undefined", null в "null".

Исключениями являются Object и Symbol. Простой объект вне зависимости от содержания возвращает "[object Object]", а Symbol возвращает "Symbol(description)":
```js script
console.log(String({})); // "[object Object]"
console.log(String(Symbol("some text"))); // "Symbol(some text)"
```
Неявные преобразования
Иногда преобразования в коде совершаем не мы, а сам язык JavaScript — например, при конкатенации. Такие преобразования принято называть неявными:
```js script
let position = 2;
console.log("Ваша позиция " + position); // Ваша позиция 2
```
При сложении со строкой всегда неявно происходит следующее преобразование:
```js
console.log("Ваша позиция " + String(position));
```

Преобразования в числа
Мы уже рассматривали несколько примеров преобразования строки в число: parseInt, parseFloat. Помимо этого, есть еще способы, но уже актуальные для всех типов данных, а не только для строк:

1. Конструкция Number(variable) позволяет получить число из строк и других типов:
```js
let num = Number("100"); // 100
let boolNum = Number(false); // 0
```
Если значение, передаваемое в Number, не может быть преобразовано в число, в результате получается NaN:
```js
let a = Number({}); // NaN
let b = Number("Hello"); // NaN
let c = Number(undefined); // NaN
```
2. Выражения с операторами сравнения. Ранее мы рассказывали об операторах сравнения ==, !=, >, >=, <, <=. Если в таких операциях участвует число, второй операнд также приводится к числу:
```js
console.log(1 < '5'); // true
console.log(100 > '50'); // true
console.log('42' == 42); // true
```
Мы также рассказывали про операторы строгого равенства (===) и неравенства (!==). Они не используют приведение типов, поэтому дают другой результат:
```js
console.log('42' === 42); // false
```
3. В разделе с операторами также упоминали унарный плюс (+). Эта запись эквивалентна Number(variable), только короче:
```js
let num = +"100"; // 100
```
Унарный плюс имеет один из самых высоких приоритетов. Рассмотрим пример:
```js
let a = '4';
let b = '2';
console.log(+a + +b); // 6
```
В примере сначала происходит преобразование значений a и b в число, и только потом они складываются. Эту запись можно немного изменить, чтобы она легче читалась:
```js
console.log(Number(a) + Number(b));
```
На практике унарный плюс почти не используют и предпочитают ему преобразование с помощью Number(...), так как оно более понятно. 
Унарный плюс нельзя применять к BigInt. Чтобы преобразовать BigInt в Number, необходимо использовать Number(value).
4. Математические операции. Если у математического оператора какой-либо из операндов не является числом, он практически всегда неявно преобразуется в число с помощью Number(variable):
```js
console.log('4' / 2); // 2
console.log(4 / '2'); // 2
console.log(4 * '2'); // 8
console.log('4px' / 2); // NaN
```
Есть одно исключение: бинарный оператор плюс (+), когда один из операндов является строкой. В этом случае будет произведена конкатенация строк:
```js
console.log(4 + '2'); // "42"
console.log('4' + 2); // "42"
console.log(4 + 2 + ' - some text'); // "6 - some text"
console.log(4 + (2 + ' - some text')); // "42 - some text"
```
Мы также ранее рассказывали про различия функции isFinite и Number.isFinite, isNaN и Number.isNaN. Глобальные функции isFinite и isNaN не используют приведение типов, а Number.isFinite и Number.isNaN используют:
```js
console.log(Number.isFinite("42")); // false
console.log(isFinite("42")); // true
console.log(Number.isNaN("hello")); // false
console.log(isNaN("hello")); // true
```
Преобразования в булевое значение
Преобразовать какое-либо значение в булевое можно с помощью оборачивания в Boolean([value]). Если value опущено или равно 0, null, false, NaN, undefined или пустой строке (""), результатом будет false. В остальных случаях результатом будет true:
```js
console.log(Boolean()); // false
console.log(Boolean(10)); // true
console.log(Boolean(0)); // false
console.log(Boolean("0")); // true
console.log(Boolean("")); // false
console.log(Boolean(" ")); // true
console.log(Boolean("false")); // true
console.log(Boolean({})); // true
```
Есть еще один способ преобразования. Мы вскользь упомянули, что оператор отрицания приводит к булевому значению и после возвращает обратный результат. С помощью двойного отрицания можно добиться более короткой записи преобразования:
```js
console.log(!!10); // true
console.log(!!0); // false
console.log(!!"0"); // true
console.log(!!""); // false
console.log(!!" "); // true
console.log(!!"false"); // true
console.log(!!{}); // true
```
Как добавить условия в код
В шаге имеется обязательный к прохождению элемент
Иногда надо выполнить код по какому-то условию. Для этого существует оператор if. Он может быть записан двумя способами.

1. Без скобок будет выполнена одна команда:
```js
if (condition) alert("hello");
```
2. С фигурными скобками ({}) — целый блок:
```js
if (condition) {
  let text = "hello";
  alert(text);
}
```
Чаще всего используют второй вариант, так как очень редко выполняется всего одна команда.

Команда или блок будут выполнены, если condition после приведения к булевому значению будет равен true. О преобразованиях разных типов в булевое значение мы подробно говорили в прошлом разделе.

Примеры преобразований:
```js
if (0) {
  // после преобразования в булевый тип, получится false,
  // следовательно этот блок никогда не будет выполнен
}

if ("hello") {
  // после преобразования строки "hello" в булевый тип, получится true,
  // следовательно этот блок всегда будет выполнен
}
```
Иногда надо сделать разветвление и выполнить один код, если выполняется условие, и другой — если не выполняется. Например, если у пользователя есть деньги на счете, оплатить заказ, а если их нет — предложить пополнить счет. Для этого можно написать два противоположных if, однако короче и читабельнее будет использовать оператор else.

Этот оператор идет сразу после блока if:
```js
if (age >= 18) {
  console.log('Вы совершеннолетний!')
} else {
  console.log('Вы несовершеннолетний')
}
```
Можно также комбинировать условия с помощью else if:
```js
if (age < 14) {
    console.log('Еще нет паспорта')
} else if (age < 18) {
    console.log('Уже есть паспорт, но все еще несовершеннолетний')
} else {
    console.log('Уже совершеннолетний')
}
```
Сложные условия с помощью логических операторов
Часто условия становятся более сложными — например, возраст меньше 18 и больше 14. Можно, конечно, написать один блок if внутри другого блока if, например:
```js
if (age < 18) {
  if (age > 14) {
    console.log('Мне 15-17 лет')
  }
}
```
Однако, если добавится еще одно условие, вложенных блоков станет три и снизится их читабельность: чем больше вложенностей, тем сложнее понимать, что к чему относится.

Чтобы решить подобные проблемы, используйте более короткую запись для сложных условий — с помощью логических операторов.

С одним логическим оператором мы уже знакомы, это отрицание (!). Разберем еще два: И (&&) и ИЛИ (||).

Оператор И (&&) по очереди получает значения операндов и приводит их к булевому типу. Если встречает false, он останавливает проверку и возвращает это значение:
```js
console.log(true && false); // false
console.log(0 && 2); // 0
console.log(null && "hello" && true); // null
```
Если же ни один операнд не равен false, оператор вернет последний:
```js
console.log(1 && 2); // 2
console.log(true && true); // true
console.log("hello" && true); // true
```
Ранее показанный пример с помощью оператора && можно переписать так:
```js
if (age < 18 && age > 14) {
  console.log('Мне 15-17 лет')
}
```
С помощью этого оператора можно также выполнять блоки кода:
```js
age >= 18 && console.log('Вы совершеннолетний!');
```
Минус в том, что код в блоке выше плохо читается, поэтому лучше использовать if (…) {}.

Оператор ИЛИ (||) также по очереди получает значения операндов и приводит их к булевому типу. Однако, если встречается true, он останавливает проверку и возвращает это значение:
```js
console.log(false || true); // true
console.log(1 || 2); // 1
console.log(0 || 2); // 2
console.log(0 || null || "hello"); // "hello"
console.log(null || "hello" || true); // "hello"
```
Если же ни один операнд не будет равен true, оператор вернет последний:
```js
console.log(false || false); // false
console.log(0 || null); // null
console.log(null || false || 0); // 0
```
Все логические операторы можно комбинировать, а еще важно знать приоритет (порядок) их выполнения:

! (Отрицание).
&& (И).
|| (ИЛИ).
Допустим, нам надо вывести сообщение о том, закрыто ли сейчас заведение. Заведение открыто по будням с 10 до 18, а по выходным с 10 до 24. Как это можно записать:
```js
if (hour >= 10 && (hour < 18 || !isWeekday)) {
  console.log('Мы открыты!')
} else {
  console.log('Мы закрыты!')
}
```
Из-за разного приоритета у операторов мы заключили второе условие в скобки. 

Если бы мы это не сделали, код условия был бы таким:
```js
hour >= 10 && hour < 18 || !isWeekday
```
А значит, получился бы следующий порядок: 

Выполняем отрицание isWeekday,
Получаем hour >= 10 && hour < 18,
Далее выполнится оператор ИЛИ с !isWeekday.
В этом случае условие некорректно, т. к. проверка || !isWeekday стала относиться к hour >= 10 && hour < 18, а не только к hour < 18. Такой код выдаст сообщение Мы открыты в любое время в выходной день.

Тернарный оператор
Часто приходится присваивать значение переменной по условию:
```js
let status;
if (hour < 10 || hour > 18) {
  status = 'closed';
} else {
  status = 'opened';
}
```
Это довольно громоздко. В JavaScript есть тернарный оператор, позволяющий сократить код, синтаксис у него такой:

Переменная = условие ? значение1 : значение2

Переменной будет присвоено значение1, если условие после приведения типа будет равно true, иначе будет присвоено значение2. Вот так с помощью тернарного оператора будет выглядеть пример со статусом:
```js
let status = (hour < 10 || hour > 18) ? 'closed' : 'opened';
```
Так же, как и в if-else, в тернарном операторе можно создавать вложенность:
```js
let allowedText = age < 14 
  ? 'Нет доступа'
  : age < 18
    ? 'Ограниченный доступ'
    : 'Полный доступ'
```
Это равносильно следующему:
```js
let allowedText;
if (age < 14) {
  allowedText = 'Нет доступа';
} else if (age < 18) {
  allowedText = 'Ограниченный доступ'
} else {
  allowedText = 'Полный доступ';
}
```
Отметим, что комбинация тернарных операторов — неудачный вариант (антипаттерн), поскольку с каждым уровнем вложенности становится сложнее читать такие выражения.

Конструкция switch
Оператор switch используется в случаях, когда необходимо выполнить разные блоки кода в зависимости от значения выражения.

Рассмотрим его структуру:
```js
switch (expression) {
  case value1:
    // Если результат выражения равен value1, то выполнится этот код
    [break;]
  case value2:
    // Если результат выражения равен value2, то выполнится этот код
    [break;]
  ...
  case valueN:
    // Код, соответствующий значению valueN 
    [break;]
  default:
    // Если не будет ни одного совпадения, то выполнится этот код 
    [break;]
}
```
Блок-схема switch выглядит так:

<img src="https://cs.sberbank-school.ru/image/full/full/resize/4862574c-3660-11ec-9d85-0242ac160002">

У switch есть несколько важных особенностей:

1. Используется строгое сравнение, поэтому в коде ниже мы всегда будем попадать в секцию default:
```js
switch ('1') {
  case 1:
    console.log('Вы ввели 1'); // этот код не выполнится 
    break;
  default:
    console.log('Вы ввели не 1')
}
```
2. Если код попал в тело case, он будет выполнять все следующие инструкции case-default до тех пор, пока он не встретит break.
```js
switch (1) {
  case 0:
    console.log('Вы ввели 0');
  case 1:
    console.log('Вы ввели 1');
  case 2:
    console.log('Вы ввели 2');
  default:
    console.log('Вы ввели больше 2')
}
```
Результатом этого кода будут три сообщения: Вы ввели 1, Вы ввели 2, Вы ввели больше 2. Если бы мы перед default поставили break, последнее сообщение не вывелось бы.

3. Возникает как следствие из предыдущего пункта возможность объединить несколько case:
```js
switch (expression) {
  case value1:
  case value2:
    // Если результат выражения равен value1 или value2, то выполнится этот код
    break;
  default:
    // Если не будет ни одного совпадения, то выполнится этот код
}
```
Сравнение switch и if-else:

1. switch быстрее находит место, откуда надо начать выполнять код.
2. Помимо того, что switch быстрее находит, откуда надо начать выполнять код, он лишь один раз вычисляет выражение, переданное на вход. Если мы в if не сохраним значение выражения, при каждом сравнении будут происходить вычисления. И чем сложнее вычисления, тем более медленным будет if.
3. В switch легче объединять блоки.
4. В switch можно легко дополнять одни блоки другими.
5. Условия в switch легче читаются.
6. В if мы можем делать сложные условия на основе нескольких значений, в то время как switch лишь строго сравнивает с одним значением.
7. if-else лучше подходит для логических выражений, в то время как switch больше подходит, когда необходимо сравнить результат выражения с фиксированными значениями.

